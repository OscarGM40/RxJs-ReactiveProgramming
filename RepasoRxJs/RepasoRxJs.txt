

¿Cuando usar RX?
1- Para manejar cualquier evento en la interfaz de usuario
2- Cuando es necesario notificar sobre cambios en uno o varios objetos a otras partes
3- En comunicación por sockets
4- Y cuando necesito trabajar con flujos de información(Streams de data).

La programación reactiva tiene tres piezas fundamentales
1- Observables
2- Subscribers
3- Operators

Los Observables son la fuente de información,la pieza fundamental.Pueden emitir múltiples valores, un único valor o no emitir ninguno(pero aún asi estar activo).
También puede emitir errores
Puede ser infinito(no completarse nunca) o finito(se completa).
También pueden ser síncronos o asíncronos.Si bien su fuerte es la asincronia,pueden ser sincronos.

Los Subscribers se "suscriben" a un Observable,es decir,están pendientes de lo que realiza ese Observable.
Consumen(o sólo la observan) la data que viene de ese Observable
Pueden recibir errores,data o eventos desde el Observable
Realmente desconocen todo lo que se encuentra detrás del Observable(si se ha filtrado,si ha pasado por varios lugares,...).

Los operadores son masivamente utilizados para TRANSFORMAR los Observables(map, group,scan,...)
También son utilizados para FILTRAR los Observables (filter, distinct, skip, debounce,...).
Y también son usados para COMBINAR Observables o para CREAR NUEVOS Observables.

Si por ejemplo tuviera un problema a resolver donde tuviera que rastrear la ubicación del usuario,pero filtrarla sólo cuando la precisión de esa data sea menor a X valor,y además seguir la aceleración de ese usuario y determinar su dirección en base al norte magnético,combinar esos valores(acimut y ubicación) y enviar esa data cada 5 segundos a la API y con la respuesta graficar una UI,con la programación reactiva podría hacer esto mucho más fácil que sin ella.

Como beneficios evita el callback hell, trabaja muy fácil sincronia y asincronia y los operadores reducen y simplifican el código.También es muy fácil transformar los streams,genera un código más limpio y fácil de leer.
Y además es fácil de implementar.
Cabe destacar que es muy fácil anexar procedimientos a posteriori sin alterar el producto final.

ReactiveExtensions(rxjs) es una API para programación asíncrona usando observables.Es una combinación de las mejores ideas para el patrón Observer,el patrón Iterator y la programación funcional.
El patrón observer es un patrón de diseño que define una dependencia del tipo uno a muchos entre objetos de manera que cuando uno de los objetos cambia su estado,notifica ese cambio a todos los dependientes(puedo ver que Kafka,Eureka,MQTT,NATS,etc usan ese patrón,no??)
El patrón iterador define una interfaz que declara los métodos necesarios para acceder secuencialmente a un grupo de objetos de una colección
Por último,la programación funcional crea un conjunto de funciones que no mutan la data,sin efectos secundarios,que realizan objetivos específicos(filtrar,transformar)

IMPORTANTE: el simbolo $ indica que es un observable(siempre debo identificar a un Observable)

NOTA: fijate que rxjs si que va a ser parte del bundle final de mi aplicación,con lo que tengo que dejarla en dependencies.Fijate como Fernando usó webpack-dev-server que levanta un servidor.
También ha configurado un webpack.config.js con el punto de entrada o qué tipos de archivos acepta(investigar más por mi cuenta este file y el modulo webpack-dev-server):


module.exports = {
    entry: './src/index.ts',
    devtool: 'inline-source-map',
    module: {
        rules: [
            {
                test: /\.tsx?$/,
                use: 'ts-loader',
                exclude: /node_modules/
            }
        ]
    },
    resolve: {
        extensions: [ '.tsx', '.ts', '.js' ]

				SECCION 02 OBSERVABLES - INTRODUCCIÓN

Fijate que crear un Observable<T> es bastante sencillo.Es muy conveniente tiparlo,ya que si uso un Observable<Product> me aseguraré que solo se emiten Products.				

const obs$ = new Observable<string>( observer => {
  observer.next('hola'); <- fijate que sólo puedo emitir strings
  observer.complete(); <- una vez completado el observer la suscribción no recibirá mas valores
  observer.next('valor que no se recibirá) <- sin embargo el Observable podría emitirlos.
})

				VIDEO 16 SUSCRIPCIÓN Y UNSUBSCRIBE

IMPORTANTE: el retorno del método subscribe() es una Subscription.En cuanto haga el subscribe a un Observable esa función retorna eso.Por consecuencia,si asigno el retorno de la función a una variable

NOTA: fijate que cancelar una subscripción no tiene nada que ver con que el Observable termine de emitir valores.Perfectamente puede seguir emitiendo valores,pero la suscripción no los recibiría.

const interval$ = new Observable<number>(subscriber => {
  let posInitial = 1;
  let contador = setInterval(() => subscriber.next(posInitial++), 1000)
})

const subs = interval$.subscribe(num => console.log('Num: ',num));

setTimeout( () => subs.unsubscribe(),3000) <- solo veré hasta el 3,pero el interval no se ha cancelado,simplemente dejé de escuchar,pero el emisor sigue "hablando".
NOTA: Subject no devuelve el valor actual en la Subscription.Sólo se dispara en el .next(value) y devuelve el value:
let subject = new Rx.Subject();
subject.next(1) <- subject emitió antes de la subscription

subject.subscribe({next: (v) => console.log('observerA: ' + v)})

IMPORTANTE: cuando llame al subscribe y me suscriba se creará una nueva instancia de la clase Observable y por consecuencia ejecutará todo su código de nuevo:

setTimeout( () => {
  subs1.unsubscribe();
  let subs2 = interval$.suscribe() <- esto empezará 1,2,3,4,5,... de nuevo
},3000) <- si bien para la 1,también crea otro objeto con una cuenta infinita,ojo!

NOTA: el return del Observable para limpieza puede dispararse o bien por el unsubscribe o bien manualmente con observer.complete.Sólo puede llamarse una vez,por la opción que suceda antes:
const interval$ = new Observable( observer => {
  const contador = setInterval( () => observer.next(initialValue++));
  setTimeout( observer.complete(), 2500) <- fijate que llama al complete()
  return( () => clearInterval(contador) <- sucederá al de 2500
})
const sub1 = interval$.subscribe(console.log)
setTimeout( sub1.unsubscribe(),5500) <- este unsubscribe no disparará el return del Observable,ya que lo dispara su setTimeout interno,que llama antes al complete

En resumen,el complete() no es lo mismo que el unsubscribe(),aunque ambos llaman al return al ser llamados.

		 AÑADIR SUBSCRIPCIONES EN CADENA

ENCADENAR SUBSCRIPCIONES: puedo invocar una función en el unsubscribe de una Subscription.Para ello se usa el método add:
subs1.add(subs2).add(subs3).
OJO,esto cuenta como una sóla,asi que llamar a subs1.unsubscribe limpiará los 3 intervalos.

Normalmente se usan otro tipo de operadores.

		VIDEO 18 -19 SUBJECT - BEHAVIOURSUBJECT - REPLAYSUBJECT

Son todo tipos de observables,que además pueden ser Observer(luego son un Observable + Observer).Por ello,pueden ser pasados como argumento de otros Observables(o de otros Subject,fijate en el bucle).
En este punto es importante entender que la clase Observable por naturaleza emite en monocasting:

const interval$ = new Observable<number>(subscriber => {
  const interval = setInterval(() => subscriber.next(+Math.ceil(Math.random() * 10).toFixed(0)), 1000);
  return (() => clearInterval(interval));
})

const subs1 = interval$.subscribe(rnd => console.log('Subscription 1: '+rnd))
const subs2 = interval$.subscribe(rnd => console.log('Subscription 2: '+rnd))
*Esto dará numeros diferentes,ya que cada Subscription es una instancia diferente de la clase Observable(monocasting).

¿Pero,y si necesito que ambas subscripciones reciban el mismo dato?Es decir que no se creen diferentes instancias.Es aqui donde entra la clase Subject y sus derivadas:
IMPORTANTE: Subject nace ya en multicasting,es decir que todas las Subscripciones recibirán el mismo valor del observer.Además,también es un observer,recuerda.

Por todo ello podria pasarlo como observer a un Observable y al hacer esto cambiar la clase Observable a multicasting(ojo que hay que suscribirse al Subject)
const subject$ = new Subject<number>(); 
interval$.subscribe(subject$);

const subs1 = subject$.subscribe(rnd => console.log('Subscription 1: '+rnd))
const subs2 = subject$.subscribe(rnd => console.log('Subscription 2: '+rnd))

NOTA:seguramente sería mejor haber creado un Subject desde un principio y en el next pasarle la lógica del Observable.
Dado que ademas es un observer,puedo terminarlo cuando quiera,emitir lo que quiera,etc:

setTimeout( () => {
  subject$.next(455);
  subject$.complete();
},3500)

				COLD OBSERVABLE VS HOT OBSERVABLE

Cuando la data es producida por el observable en sí mismo es considerado un "Cold Observable".Pero cuando la data es producida FUERA del Observable es llamado "Hot Observable"				
En este caso la clase Observable es un Cold Observable,pues produce sus propios valores.Sin embargo,al pasarle el Subject,lo transforme en Hot Observable,ya que la data ahora para ese Subject se produce fuera

Dado que este tipo de operaciones pueden dar lugar a memory leaks la libreria ya ofrece otra forma de crear Observables,dependiendo de las necesidades,manejando por nosotros el complete,error,next etc...

			SECCION 04 CREAR OBSERVABLES MEDIANTE LIBRERIA RXJS

Es momento de utilizar funciones para crear observables!, esto nos ayudará a reducir mucho el tiempo a la hora de crear nuevos observables.

Los temas principales de la sección son:
1- of
2- fromEvent
3- interval
4- timer
5- asyncScheduler

Mas adelante veremos otras funciones que crean observables, pero por ahora enfoquemos nuestra atención en las básicas y más comunes.

					VIDEO 23 FUNCIÓN OF

El método/función of<T> me permite crear un Observable en base a un listado de elementos.Emitirá los valores de manera síncrona y se completará tras emitir el último 					of<T>(...args:Array<T>):Observable<T> 

const of$ = of<number[]>(1,2,3,4,5,6);

console.log('Inicio del of sincrono')
of$.subscribe({
  next: v => console.log(`Next: ${v}`),
  error: err => console.log(err),
  complete: () => console.log('Terminada la secuencia'),
})
console.log('Fin del of sincrono')
* Es importante comprender que no es lo mismo of([1,2,3,4,5,6]),que sólo tiene un argumento que un of(1,2,3,4,5,6) que tiene 6 argumentos.
El primero sólo emitirá un valor,el segundo 6.Asi pues of() emite los argumentos que reciba de uno en uno secuencialmente y de manera sincrona.	

Fijate que puede emitir cualquier cosa:
const obs$ = of<any>( [1,2],{a:1,b:2},function(){},true,Promise.resolve('Resolved'))
obs$.subscribe(console.log)

Por último es importante especificar el tipo de dato que va a fluir a través del Observable,ya que normalmente trabajaré con uno sólo.
NOTA: fijate en el uso de Promise.resolve(valueToEmit) para simular una Promise que se resuelve exitosamente.

					VIDEO 24 FUNCIÓN fromEvent 

La función fromEvent<Event>(document,'scroll') me permite crear un Observable en base a un evento HTML.Necesita un target,en este caso es todo el documento,pero puede ser un div o un botón,simplemente(el argumento admite un selector como getElementById)					

Esta función,junto con alguna más,es una de las más usadas.
NOTA: Event es el padre de todos y es demasiado genérico.Para saber que tipo de evento es primero lo disparo y despues lo veo por consola:

const src1$ = fromEvent<MouseEvent>(document,'click')
const src2$ = fromEvent<KeyboardEvent>(document,'keyup') <- no dejar sin el genérico

const observer: Observer<any> = {
  next: (val) => console.log('next:',val),
  error: err => console.error('Error',err),
  complete: () => console.info('Observer completed')
}

src1$.subscribe(observer);
src2$.subscribe(observer);

* Veré que son MouseEvent y KeyboardEvent.De otra forma no voy a poder acceder a clientX o clientY en el primero o a key o keyCode en el segundo

src1$.subscribe(e => console.log(e.clientX,e.clientY));
src2$.subscribe(e => console.log(e.key));

Fijate que podria desestructurar los argumentos de esa callback y fijate también que esta función tiene un gran numero de usos posibles.

				VIDEO 25 FUNCIÓN RANGE

La función range(start,end) crea un Observable que emite una secuencia de números en base a un rango.Ojo,son sólo números,y por defecto son síncronos aunque pueden transformarse a asíncronos usando un asyncScheduler:
range(start:0,count?,scheduler?) <- fijate que por defecto empezará en 0,y al ser opcional count stambién me vale para una cuenta infinita.Por último el tercer argumento permite usar 'scheduling' en las emisiones de las notificaciones.

const obs$ = range(-5,10,asyncScheduler) <- a pesar de lo que pueda parecer emitirá del -5 al 4(diez emisiones) y no hasta el 10.Además ya no será sincrono(asyncScheduler viene del core de rxjs)

		VIDEO 26 Y 27 INTERVAL Y TIMER FUNCIONES PARA INTERVALOS DE TIEMPO

Interval crea un Observable que emite numeros positivos secuencialmente desde el 0 . Más o menos sería como setInterval de Javascript.
Por otro lado timer sería como setTimeout,es una cuenta atrás,al de X ms emitirá un valor.Aunque puede ser más poderoso que simplemente emitir un valor cuando termine la cuenta,ya que puede empezar a emitir más valores en un intervalo concreto,
NOTA: ambos son asíncronos por naturaleza,a diferencia de of o range(y seguramente from) que son síncronos.

const observer: Observer<any> = {
  next: val => console.log('next',val),
  error: err => console.error('error',err),
  complete: () => console.log('complete')
}

const interval$ = interval(1000)

interval$.subscribe(observer)

IMPORTANTE: puedo combinar este Observable con operadores como take o skip para personalizarlo.

En cuanto al timer,ya lo he mencionado,emitirá un valor(el 0 en principio) en cuanto termine la cuenta atrás.De nuevo,no es un proceso síncrono,sino que empezará tan pronto el stack de callbacks de javascript lo permita

* Si bien timer por naturaleza sólo emite un valor,le puedo pasar un segundo argumento y seguirá emitiendo valores con ese intervalo de ms entre ellos(con lo que esta firma es más poderosa que interval):
const timer$ = timer(2000,1000)<- espera 2s para emitir el 0 y despues emite 1+ cada 1seg.Fijate que esto no puedo hacerlo con un interval

Fijate que por lo mismo un timer(1000,1000) sería lo mismo que un interval(1000).
No sólo esto,si ejecuto timer() sin argumentos emitirá el 0 inmediatamente.

Supongo que lo más interesante será emitir lo que yo quiera,y no ese 0.Fijate que aqui se abre un abanico de posibilidades,como mandar eso a las 12 de la noche o desde ahora más 5 segundos:
const ahoraEn5= new Date();
ahoraEn5.setSeconds(ahoraEn5.getSeconds() + 5);
const timer$ = timer(ahoraEn5)

IMPORTANTISIMO: realmente estas cuentas positivas incrementales no me son útiles.Pero en el subscribe hay si que puedo realizar cualquier acción:
timer$.subscribe( (_) => console.log('hi') ) <- tal como está,al de 5 segundos emitirá el console.log.Asi si tiene sentido,ya que puedo ejecutar cualquier cosa a intervalos regulares,en un momento concreto o tras un periodo inicial concreto.Amazing spiderman,asinto.

				VIDEO 28 ASYNC SCHEDULER

AsyncScheduler no crea un Observable,sino una Subscription.Recuerda que el retorno de método subscribe() crea una Subscription.
AsyncScheduler me dará más control sobre las funciones anteriores:
setTimeout()
setInterval()
Veamoslo:

/* fijate la similitud con setTimeout al usar asyncScheduler.schedule asi: */
asyncScheduler.schedule(saludar, 2000);
asyncScheduler.schedule(saludar2, 3000, 'Fernando'); //tercer argumento para argumentos de la funcion del primer argumento


/*  si quiero pasar un state no puedo usar una arrow function,tiene que ser una function normal asinta.Fijate que esta forma combina setTimeout + setInterval*/
const subs = asyncScheduler.schedule(function (state) {
  console.log('state', state)
  this.schedule(state + 1, 1500)
}, 3000, 0)

setTimeout(() => subs.unsubscribe(),+'6000')

Fijate que la segunda forma con la function plana permite mandar un nuevo estado,configurar cada cuanto,la primera emisión,etc...Podría ser útil.

IMPORTANTE: fijate que todas estas opciones,asyncScheduler,timer,interval o incluso las funciones de Javascript me permiten mandar ese proceso al callback,todos son asincronos,con lo que no bloquean la siguiente instruccion.

				VIDEO 29 OBSERVABLE FROM

La función from permite crear un Observable desde un valor iterable,como un array,una promise,otroObservable, entre otras cosas.
Fijate que from va a iterar siempre que pueda:
from('Fernando') <- itera por cada char F-e-r-n-a-n-d-o
from([1,2,3,4,5,6]) <- itera por el array 1,2,3,4,5,6 <- observa que recibe un arg y emite 6.Nunca sucederá esto con of(a menos que use spread operator)

 TIP: fijate que debo añadir TIP a mi repertorio y fijate que puedo meter una Promise en el argumento(supongo que con of también puedo):

const source$ = from( fetch('https://api.github.com/users/klerith'));

source$.subscribe(async observer => await observer.json().then(console.log));

IMPORTANTE: Rx ya provee su propia implemetación de la API fetch usando el operador ajax,lo cual obviamente sería mejor elección.

Recuerda que también puedo iterar una función generadora con from:
const generadora = function*() {
  yield 1; yield 2; yield 3; yield 4; yield 5;
}
const iterable = miGenerador();
from(iterable).subscribe(observer)
Fijate que también podria hacer:
from(generadora()).subscribe(observer).
NOTA: debo memorizar que una funcion* generadora va marcada con el asterisk.

IMPORTANTE: este tipo de Observables(of,from) se completarán al recorrer el último elemento,a no ser que tenga un ciclo infinito de emisiones


			SECCION 05 PRIMEROS OPERADORES RXJS

Es al usar operadores donde ReactiveX brilla,ya que permite jugar y manipular los streams de datos de una forma sencilla y legible,además de sorprendente.
En esta sección veremos los operadores map,pluck,mapTo,filter,tap,reduce,scan y como encadenar más de uno.

				OPERADOR MAP

Es,quizás,el más común y usado,ya que permite transformar la emisión de entrada del stream del Observable en otra emisión diferente
IMPORTANTE: el operador MAP trabaja con cualquier dato que emita el Observable y puede transformalo en cualquier otro(aunque puedo restringir esto mediante el tipado->map<T,R>)

IMPORTANTE: recuerda que los operadores necesitan abrir el stream con pipe():

range(1, 5).pipe(
  map<number, number | string>(val => String(val * 10))
).subscribe(console.log)

const keyup$ = fromEvent<KeyboardEvent>(document,'keyup') // <- solo los asintos tipamos fromEvent
const keyupWithCode$ = keyup$.pipe(
  map(event => event.code)
)

keyupWithCode$.subscribe(val => console.log('code: ',val))

			OPERADOR PLUCK

El operador Pluck es sumamemente útil cuando quiero extraer un único valor del objeto que estoy recibiendo en el stream de datos y que ese valor sea la única salida del Observable después.
pluck({v:2}) <- la salida será 2
*Ojo,la salida es el value,pero se apunta a la key.

Probemos con el ejemplo anterior:
let keyup$ = fromEvent<KeyboardEvent>(document,'keyup').pipe( pluck('key') ).subscribe(console.log)

Realmente no tiene más ciencia.
TIP: puedo acceder a propiedades anidadas,es decir, a los valores de propiedades de objetos dentro de objetos 

keyup$.pipe(
  pluck('target','baseURI')<- simplemente añado argumentos extra

			  OPERADOR mapTo

El operador mapTo(valueRetorned) me permite transformar la entrada en una salida específica,la misma.Pide un valor de retorno como argumento: 

const keyupMapTo$ = keyup$.pipe(
  mapTo<KeyboardEvent,string>('tecla presionada')
  ).subscribe(console.log)

  * Realmente no parece muy útil transformar toda entrada en una misma salida en programación

			  OPERADOR FILTER

El operador filter 'filtra' la entrada del stream de datos en base a una condición lógica.Sólo saldrán del stream los elementos que cumplan esa condición(la resuelvan a true).

/* fijate que si filter recibe el index es porque iterará en orden si o si */
const range$ = range(1, 10).pipe(
  filter((x, i) => x % 2 !== 0)
  ).subscribe(console.log)

			ENCADENAMIENTO DE OPERADORES

Al abrir la zona de operadores con pipe() puedo encadenar cuantos quiera.Debo de tener en cuenta que se ejecutan secuencialmente,y cada uno recibirá como entrada la salida del anterior:

const keyup$ = fromEvent<KeyboardEvent>(document,'keyup').pipe(
  map<KeyboardEvent,string>(event => event.code),
    filter( code => code === 'Enter')
    )
				OPERADOR TAP

Este operador permite disparar efectos secundarios al stream de datos(éste no se debe ver afectado).Al emitir un observable un valor puedo ejecutar una acción(fijate que tap no devuelve un Observable,no devuelve nada,simplemente ejecuta su código).
Es bastante común para impresiones en consola.

TIP:fijate que la firma indica que puedo pasarle un observer(en realidad es un PartialObserver,que es un Observer con menos características):
(alias) tap<number>(observer?: Partial<TapObserver<number>>)

/* fijate que la instrucción return del operador tap es auto-ignorada */
const numeros$ = range(1, 5).pipe(
  tap(x => { console.log('en el tab', x); return 100 }),
  map(val => val * 10),
  tap({
    next: valor => console.log('en el partial observer',valor),
    complete: () => console.log('Se terminó el Observable')
  })
)

/* fijate que un Partial Observer no me obliga a usar las tres propieades.Un Observer si,tengo que usar el next,el error y el complete */

			PRACTICA LABORATORIO SCROLL

Fijate que para esta practica hay que tener bien claro como sacar el porcentaje de lo que se lleva scrolleado.
ClientHeight: es la altura actual de la pantalla(por ejemplo 350px)
ScrollHeight: es todo el contenido que hay en el html,haya scrolleado el usuario o no(por ejemplo,800px)
Asi pues,puedo deducir ya que tiene 450px ocultos por scrollear el usuario.
ScrollTop: esta variable indica a que distancia estoy de la posicion 0 top.Diria que no lo explica bien,es la distancia que ya he escrolleado,luego nunca será más de 450px
Si tuviera un scrollTop de 300/450 me dará 0.6 que por 100 será un 66%

Sabiendo esto,puedo suscribirme al scroll de un documento html y sacar este porcentaje:

const scroll$ = fromEvent(document, 'scroll');
const progress$ = scroll$.pipe(
  map(event => calculateScrollPercent(event)), <- podria usar map(calculateScrollPercent)
);

const calculateScrollPercent = (event) => {
 const { clientHeight,scrollTop, scrollHeight } = event.target.documentElement;
 return scrollTop / (scrollHeight - clientHeight) * 100;
} <- recuerda multiplicarlo por 100

Por último le cambio el porcentaje del width:
progress$.subscribe(porcentaje => {
  progressBar.style.width = `${porcentaje}%` //al loro con el string explicito
})

				VIDEO 42 OPERADOR REDUCE

Básicamente el operador reduce( (acc,curr) => acc + curr,0) hace lo mismo que la función.Aplica una función acumuladora,la cual podria definir antes:

const totalReducer = (acumulador: number, valor: number) => {
  return acumulador + valor;
}

/* fijate que el operador take(n) toma los primeros n valores y automáticamente hace terminar al Observable.Y fijate en la importancia de esto */
timer(3000, 1500).pipe(
  take(3),
  tap(console.log),
  reduce( totalReducer,5)
)
  .subscribe({
    next: val => console.log('Next:', val),
    complete: () => console.log('Completed')
  })

				  OPERADOR SCAN

El operador scan es exactamente igual que el operador reduce con la diferencia que los valores van saliendo según son emitidos,pero sigue devolviendo el valor acumulado únicamente.
scan( (acc,cur) => acc + cur,0) <- es un reduce pero no emitirá sólo 21 en la última emisión.

const numeros = Array.of(...Array(6).keys()).map(x => x + 1);

const totalAcumulador = (acc: number, val: number) => acc + val;

from(numeros).pipe(
  scan(totalAcumulador,0)
).subscribe(console.log)

Veré 1,3,6,10,15 y 21 en vez de sólo el 21.

IMPORTANTE: este operador tiene la misma funcionalidad que el store de Redux:
 /* scan funciona igual que el store de Redux,imaginemos un Usuario cualquiera */
interface Usuario {
  id?: string;
  autenticado: boolean;
  token?: string;
  edad?: number
}

const user: Usuario[] = [
  { 'id': 'fernando', autenticado: false, token: null },
  { 'id': 'fernando', autenticado: true, token: 'ABC' },
  { 'id': 'fernando', autenticado: true, token: 'ABC134' },
]
/* fijate que simplemente quiero devolver el current(cada iteración) y el acumulado.Incluso le puedo dar un valor inicial */
const state$ = from(user).pipe(
  scan<Usuario,Usuario>((acc, cur) => {
    return { ...acc, ...cur }
  }, {autenticado:false, edad: 33 })
)
/* ahora sólo quiero saber los cambios en el id del usuario */
const id$ = state$.pipe(
  // pluck('id')
  map(state => state.id),
  distinctUntilChanged()
).subscribe(console.log)

				SECCION 06 OPERADORES NO TAN COMUNES

Si bien este término de no tan comunes es muy relativo,los veremos como una segunda categoría,aunque pueden llegar a ser básicos en el día a día.Veré los siguientes:
take, first, takeWhile, takeUntil, skip ,distinct, distinctUntilChanged,distinctUntilKeyChanged

			OPERADOR TAKE

Este operador es sumamente útil cuando quiero limitar la cantidad de emisiones que un Observable puede tener.Recuerda que va a completar la Subscription(no completa el Observable,sino la Subscription)			

const numeros = [...Array(10).keys()].map(x => x += 1)

from(numeros).pipe(
  tap(console.log),
  take(5)
).subscribe({
  next: val => console.log('Next:', val),
  complete: () => console.log('Completed')
})

Puedo observar que take completa la Subscription,ojo,no el Observable,como habia dicho antes.

				OPERADOR FIRST

El operador first(predicate) tomará los primeros x valores que cumplan la condición.Si se usa sin argumentos toma el primero únicamente,asi que es el homónimo de take(1):

const click$ = fromEvent<MouseEvent>(document, 'click')

click$.pipe(
  // take(1),
  first()
) .subscribe({
  next: val => console.log('Next:', val),
  complete: () => console.log('Completed')

Sin embargo,normalmente se usa con una expresión lógica,dado que es muy potente con el predicado:
Imaginemos el mismo ejemplo anterior,pero en vez de tomar el primero,tomar el primer click en determinada coordenada(clientY > 150):

/* first es muy potente con el predicado */
click$.pipe(
  tap<MouseEvent>(console.log),
  map( ({ clientX, clientY }) => ({ clientY, clientX })),
  first( ({clientY}) => clientY > 200)
  // first<MouseEvent>((event) => event.clientY > 150)
).subscribe({
  next: val => console.log('Next:', val),
  complete: () => console.log('Completed')
})
});

Fijate en la destructuración tan bonita que hizo

					OPERADOR TAKEWHILE

El operador takeWhile(condition,inclusive?:boolean) permite recibir valores mientras la condición del argumento se cumpla.Recibe un segundo argumento opcional que incluye la emisión que hizo completar la Subscription porque dio false:
takeWhile( x => x < 4) <- tomará las emisiones mientras x sea menor a 4

const click$ = fromEvent<MouseEvent>(document, 'click');

click$.pipe(
  map(({ x, y }) => ({ x, y })),
  takeWhile(({ y }) => y < 150, true)
).subscribe({
  next: val => console.log('Next:', val),
  complete: () => console.log('Complete')
})
Fijate que la opcion de ver la emision que rompe la condición puede ser muy útil,y que también el propio operador tiene pinta de ser útil.

				OPERADOR TAKEUNTIL

Este es el primer operador del curso que recibe como argumento otro Observable.Esto abre un nuevo campo de posibilidades,ya que un primer Observable puede estar emitiendo hasta que suceda la emisión del segundo,pudiendo ser un click o cualquier cosa:
interval$ (1,2,3,4,5) 
click$ = fromEvent ...
Puedo tener un interval que emita valores hasta que haga un click en un botón concreto.

const boton = document.createElement('button');
boton.textContent="Detener timer"
boton.style.cursor="pointer"

document.querySelector('body').append(boton);

const interval$ = timer(500,1000)
const click$ = fromEvent(boton,'click')

interval$.pipe(
  takeUntil(click$)
).subscribe({
  next: val => console.log('Next:',val),
  complete: () => console.log('Completed'),
})
Fijate que interesante,y fijate como recibe el Observable dos takeUntil,pero me suscribo al Uno.

				OPERADOR SKIP

El operador skip(n:number) me sirve para saltar u omitir las siguientes n emisiones.Es bastante sencillo realmente.
TIP:fijate que skip tiene las versiones que tiene take,es decir que hay skip,skipFirst o skipUntil,aunque no sean exactamente lo mismo hay muchos más operadores de los que veo en el curso.

const interval$ = timer(2000,1000)
const click$ = fromEvent(boton,'click').pipe(skip(2)); <- omitirá los dos primeros

interval$.pipe(
 takeUntil(click$)
 ).subscribe(console.log) <- recuerda que takeUntil pide un Observable por argumento.

				OPERADOR DISTINCT

El operador distinct deja pasar únicamente los valores que no han sido previamente emitidos por el Observable.Asi pues,si un Observable emitiera los valores 1,1,2,3,3,4,1 el distinct filtraría las emisiones no emitiendo más de una vez el 1 y el 3

IMPORTANTE: distinct usa el operador de equidad triple igual para comparar emisiones,asi que emitir 1 y "1" serán dos emisiones distintas.
TIP: las PropTypes serían en runtime(tiempo de ejecución) y Typescript es en buildtime(tiempo de compilación)
TIP: midu recomienda sacar los estados de la app afuera:
interface AppState {
  subs: Sub[],
  subsCount: number
  }

  const Home: React.FC = () => {
    const [subs,setSubs] = useState<AppState["subs"]>([]) <- fijate en el uso de computadas
    const [subsCount,setSubsCount] = useState<AppState["subsCount"]>();

Bien,fijate que distinct(callback) funcionará sin argumentos para primitivos,pero en objetos,no,ya que cada objeto es diferente:

const personajes: Personaje[] = [
  {
    nombre: 'Megaman'
  },
  {
    nombre: 'X'
  },
  {
    nombre: 'Zero'
  },
  {
    nombre: 'Dr. Willy'
  },
  {
    nombre: 'X'
  },
  {
    nombre: 'Megaman'
  },
  {
    nombre: 'Zero'
  },
]

const personajes$ = from(personajes).pipe(
  distinct(p => p.nombre) <- ya son todos distintos,para que distinct funcione necesito una cb
).subscribe({
  next: v => console.log(`Nombre: ${v.nombre}`)
})

			OPERADOR DISTINCT UNTIL CHANGED

Este operador también es importante.Es muy parecido al distinct,pero difiere en cuanto el distinctUntilChanged emite valores siempre y cuando la emisión anterior no sea la misma.
Por ejemplo si tuviera estas emisiones => 1,2,2,1,3,2  realmente sólo tengo los dos 2 con emisiones repetidas consecutivas.Fijate que distinct daría una salida muy diferente

IMPORTANTE: la firma del operador distinctUntilChanged(comparator) lleva un comparable como argumento opcional.Tendré que usarlo si quiero comparar propiedades de objectos,ya que distinctUntilChanged() sin argumentos de nuevo sólo valdrá para primitivos.

from(personajes).pipe(
  distinctUntilChanged( (anterior,siguiente) => anterior.nombre === siguiente.nombre)
).subscribe(console.log)

* Sin embargo,esto podría resumirse incluso aún más con el siguiente operador

			OPERADOR DISTINCT UNTIL KEY CHANGED

			
 Suponiendo que tengo un Observable que emite valores en forma de Object(lo cual es muy común) puedo entrar hasta una key con este operador y olvidarme de tener que usar el argumento en forma de función compare anterior.
 Imaginando esta sucesión de emisiones => {k:1},{k:2},{k:2},{k:1} va a emitir el 1,2 y 1(ojo,no hace como el distinct,mirando en todo el histórico de valores,sólo mira que el valor de una propiedad no sea el mismo:

const personajes$ = from(personajes).pipe(
   distinctUntilKeyChanged('nombre')
   ).subscribe({
     next: v => console.log(`Nombre: ${v.nombre}`)
})

Fijate que esto se puede hacer con objetos anidados:
from(champions).pipe(
  pluck('code'), <- la propiedad code es un objeto dentro de cada campeón
  distinctUntilKeyChanged('serie') <- compruebo las emisiones de champion.code.serie

				SECCION 7 OPERADORES DE TIEMPO

Estos operadores de alguna forma se enfocan en trabajar con intervalos de tiempo,regulando las emisiones de los Observables:
Veré los siguientes => debounceTime, throttleTime,sampleTime,sample y auditTime


				OPERADOR DEBOUNCE TIME

El debounceTime me ayuda a contar cuantos miliseconds han pasado desde la última emisión,en cuanto suceda esto se emitirá el siguiente valor.Este operador me va a ayudar a restringir la cantidad de emisiones de un Observable.
Fijate que el ejemplo que pone es justo lo que necesitaré el 90% de las ocasiones:
const input = document.createElement('input')
document.querySelector('body').append(input);

const input$ = fromEvent(input,'keyup');

input$.pipe(
  pluck('target','value'),
  debounceTime(1000),
  distinctUntilChanged(),
).subscribe(console.log)
Parece que el orden también importa,y va primero el debounceTime.
En cuanto a Angular puedo suscribirme al valueChanges de un FormControl(por cada control) o si no usar la clase Subject().

				OPERADOR THROTTLE TIME

Tip: una interfaz de lógica de negocio es aquella que debería explicar al mostrar mi app.Por ejemplo Usuario o Cliente.Otras que se usarían para tipar States o Reducers irían en otra clase.
El primer grupo puede ir en el file types.d.ts(en un archivo .d.ts sólo puede ir definiciones de tipos(interfaces)
IMPORTANTE: para pasar un setter de un useState:
const [ subs,setSubs] = useState<Sub[]> <- quiero pasar este setter:
<SubList onNewSub={setSubs} 
interface ListProps {
  onNewSub: React.Dispatch<React.SetState<Sub[]>> <- fijate que necesito el namespace React

Sin embargo no se recomienda pasar el setter directamente,sino una función que maneje la lógica necesaria:
const handleNewSub = (newSub:Sub) => {
  setSubs(subs => [...subs,newSub])
  Fijate en la importancia de este paso y en llamar a los setters con callbacks(debería hacerlo siempre??)
 
useReducer vs useState:un reducer es preferible sobre un state cuando tengo lógica que involucra multiples sub-valores o cuando el siguiente estado depende del primero:
const initialNumberState ={
 valueOne:0,
 valueTwo:0,
 valueThree:0,
}
const numberReducer = (prevState,action) => {
  if(action.type === 'INCREASE_NUMBER'){
    const { valueOne,valueTwo,valueThree } = prevState <- recuerda que puedo desestructurar el state,es un simple objeto más
    const newValueOne = valueOne + 1;
    const newValueTwo = valueOne + valueTwo + 1;
    const newValueThree = valueOne + valueTwo + valueThree + 1; 
    return {
      valueOne: newValueOne,
      valueTwo: newValueTwo,
      ...
Fijate que el reducer me hará de useState,ojo:
const CustomComponent = (props) => {
 const [numberState,dispatch] = useReducer(numberReducer,initialNumberState); <- ya estoy en el punto que quiero,en vez de un useState un reducer,fijate que este reducer es intrinseco al componente.

 const handleClick = () => {
    dispatch({type:'INCREASE_NUMBER'}) <- no necesitaré payload por ser muy asinto aún.

Hay otra solución que es simplificar el estado.En este caso tres useState serían la solución.Fijate que no siempre será conveniente hacerlo.
const [handleValueOne,setHandleValueOne]= useState()
const [handleValueTwo,setHandleValueTwo]=useState() etc...

Dado que React puede juntar varias llamadas a setState en una única update,(recuerda que setState es asíncrono,y por ello this.state y this.props cambiarán asíncronamente,no inmediatamente	),no debería confiar en sus valores previos pues podrían estar mal.
this.setState({counter: this.state.counter +1}) <- mal,confio en el prevState
setCounter(counter+1) <- mal,confio en el prevState

Para solucionar esto debo usar una segunda forma de useState que acepta una función callback en vez de un argumento
setCounter( counter => counter +1) .
Al usar la callback me aseguro que el counter es suministrado justo en el momento de la llamada,evitando cualquier posible falseo de datos.Interesante

El throttletime funciona justo al contrario que debounceTime.Emite el valor y despues ignora las siguientes emisiones durante x milisegundos.
Por ejemplo con un throttle(1000) si se emite un valor lo emitirá inmediantemente, mientras que el debounceTime espera 1000ms y coge el último.
Puedo apreciar las diferencias con un simple fromEvent: 

click$.pipe(
 // debounceTime(3000),
    throttleTime(3000)
).subscribe(console.log)
Fijate que por esto,por que debounceTime espera esos 1000ms es que lo usamos tanto en peticiones,ya que hay que esperar al input del usuario
TIP: hay una configuración que permite ver la primera y última emisión,dado que la pierde por defecto:

const input$ = fromEvent(input, 'keyup');
input$.pipe(
  throttleTime(3000,asyncScheduler,{
    leading:true,
    trailing:true
  }),
  pluck('target', 'value'),
  distinctUntilChanged(),
).subscribe(console.log)
TIP: recuerda que un reducer necesita un reducer y el initialState para funcionar.

const formReducer = (state:FormState["InputValues"],action:Action ) => {
  switch(action.type) {
    case "change_value":
      const {inputName,inputValue}= action.payload; <- putos pros
      return {
         ...state,
	 [inputName]:inputValue <- siempre computa o gira la de la izquierda
	 }
    case "clear":
      return INITIAL_STATE

fijate como puedo declarar un type con varias firmas:
type Action = {
  type:"change_value",
  payload: {inputName: string, inputValue: string }
} | { type: "clear" <- Action podrá ser dos tipos diferentes de objetos(recuerda que hay otra sintaxis por ahi).
Ya solo sería llamar al dispatch en el componente.Muy limpio y sencillo.
Fijate que el store es una cosa y los reducers otra muy diferente
Lo suyo es crear un hook ojo:
const useNewSubForm = () => {
  return useReducer(formReducer,INITIAL_STATE); 
  }

  const [a,b] = useNewSubForm() <- precioso
Fijate como recomienda también Midu compaginar la response de una API con la interfaz del programa
const mapFromAPIToSubs = (apiResponse: SubsResponseFromAPI):Array<Sub> => { 
  return apiResponse.map( subFromApi => {
    const { months: subMonths, profileUrl: avatar, nick, description } = subFromApi;
    return { nick,description,avatar,subMonths }
    fetchSubs().then( apiSubs => {
    const subs = mapFromAPIToSubs(apiSubs)
    setSubs(subs)
Fijate que es mejor usar programación declarativa:
fetchSubs()
  .then(mapFromAPIToSubs)
  .then(setSubs) <- debo aspirar a esto,asinto
* Este es un ejemplo sencillo con un método,pero puedo usar el patrón adapter    
Fijate que no es recomendable enseñar la implementación,asi que era mejor hacer esto:
const useForm = () => {
  const [inputValues,dispatch] = useReducer(formReducer,INITIAL_STATE);
  const clearForm = useCallback( () => dispatch({type:'clear'}),[]);

  return {
    formState:inputValues,
    clearForm
    }
    Ahora al llamar al hook no mando el puto dispatch(esto es ocultar la implementación)

			   OPERADOR SAMPLE TIME

El sampleTime(n) emite el último valor emitido repetidamente cada n milisegundos.Si no se emitió un valor en ese segundo(n) no emitirá nada,ojo.

const click$ = fromEvent<MouseEvent>(document,'click');

click$.pipe(
  sampleTime(2000),
  map( ({x,y}) => ({x,y})),
).subscribe(console.log)
Fijate que es más apropiado primero filtrar con el sampleTime y despues transformar esa emisión.De otra forma transformaria todas las emisiones,consumiendo recursos innecesarios.
TIP:como norma general primero se filtra con operadores de filtrado y despues se transforma o procesa.

				OPERADOR SAMPLE

El operador sample(Observable$) emite el último valor emitido por el Observable main al que estoy suscrito cuando el Observable interno que le pase al sample(Observable$) emita un valor				
Si el Observable interno emite una segunda vez sin que el Observable main emita nada no habra emisión,es decir,debe haber emitido algo:

const interval$ = timer(500,500);
const click$ = fromEvent(document,'click')

interval$.pipe(
  sample(click$)
).subscribe(console.log)
Fijate que puede ser interesante ocultar las emisiones de un Observable hasta que suceda alguna acción.

				OPERADOR AUDIT TIME

El auditTime emite el último valor que ha sido emitido por el Observable en un tiempo determinado.Esto lo puedo comprobar con un tap + un auditTime:

const click$ = fromEvent<MouseEvent>(document, 'click');

click$.pipe(
  map( ({x,y}) => ({x,y})),
  tap(val => console.log('tap', val)),
  auditTime(2000),
).subscribe(console.log)

Este operador es muy útil para filtrar spam de emisiones.Parece que podría sustituir al debounceTime??

			SECCION 08 PETICIONES AJAX CON PROGRAMACIÓN REACTIVA

Las extensiones reactivas ya nos cubren con una forma de realizar peticiones AJAX.RX tiene formas para hacer peticiones POST,PUT;DELETE,PATCH o GET,etc...
También puedo configurar Headers o procesar la respuesta.
TIP: puedo pasar un Observable a Promise con Observable.toPromise().Obviamente no devuelve un Observable sino una Promise.
const sample = val => Rx.Observable.of(val).delay(1000)
sample('first').toPromise().then(result => console.log('from the Promise',result)

			CONCEPTOS SOBRE PETICIONES NORMALES - SIN USAR RX

Primero que nada la api FETCH o axios trabajan en base a Promesas y no en Observables(o streams de datos).Esto ya da una cierta desventaja.

UNO: Una promesa no puede ser cancelada.Una vez que se mande,se resolverá exitosamente o no,pero no se puede cancelar.

DOS: la Response de esa Promesa será un Readable Stream y no la data en sí.Tengo que procesar ese Stream(leerlo y transformarlo),mediante otra promesa(.json() | text() | blob()...)

TRES: realmente el manejo de errores no está bien implementado.Ellos ya me mandan su propio error.Si hago una petición a una url no válida,ya me vendrá medio masticado todo el error,pero incluso me viene un body de nuevo,etc.Al final siempre hay que crear una función para mi lógica al producirse el error:

const url = 'https://api.github.com/users?per_page=5';

const fetchPromesa = fetch(url);

const handleError = (response:Response) => {
  if(!response.ok) throw new Error(response.statusText);
  return response
} 
fetchPromesa
  .then(handleError)
  .then(resp => resp.json())
  .then(console.log)
  .catch( err => console.warn(err)) <- esto traerá dos errores,el suyo y el mio

NOTA: fijate también que he necesitado 3 o 4 promesas para realizar una tarea tan sencilla.Además,ni siquiera hemos entrado en transformación de la data,etc... y ya tengo mucho código spagueti macarrón.

		PETICIÓN HTTP USANDO AJAX DE RXJS + OPERADOR CATCH ERROR

Desde la version 6 puedo crear una instancia de Ajax usando el operador ajax(from rxjs/ajax).

 const url = 'https://api.github.com/usersxxx?per_page=5';

 const users$ =  ajax(url); 

 users$.pipe(
   pluck('response'),
   catchError(err => of(err))
 ).subscribe(console.log)
Desde luego es mucho más sencillo.Además,quedaron posibles mejoras.Esto es lo más básico.
TIP: el operador catchError debe de retornar otro Observable(o un error? con el operador throw??)

				GET JSON METHOD

Puedo acceder a la respuesta tras pasarla por json() usando el método getJSON.Fijate que incluso puedo pasar Headers:
const url = 'https://httpbin.org/delay/1';

ajax.getJSON(url,{
  "my-type":'texto-mu-complejoh'
}).subscribe(console.log)

Recuerda un formulario emite un FormEvent<T> al ser submiteado.
Cuando un user interacciona con el teclado emite un KeyboardEvent(uno por cada pulsación)
Todos heredarán en React de SyntheticEvent

TIP:fijate que Observable/stream es practicamente lo mismo.Cuando decimos que puedo combinar dos Oservables significa que puedo combinar dos streams
Un stream puede ser usado como la entrada de otro,incluso múltiples streams pueden ser usados como la entrada de otro.Puedo mergear dos streams,puedo filtrarlo,y puedo transformarlo.

				DIFERENCIAS ENTRE GET-JSON Y AJAX

Parece que la diferencia es que uno llama al json() y el otro no.Investigar más.Fijate como manejo los errores,algo primordial:

const url = 'https://httpbinxxx.org/delay/1';

const handleError = (resp: AjaxError) => {
  console.warn('Error:', resp.message)
  return of({
    ok:false,
    usuarios:[]
  })
}

const obs$ = ajax.getJSON(url, {
  "my-header": "content of my header"
}).pipe(
  catchError(handleError)
);
const obs$2 = ajax(url).pipe(
  catchError(handleError)
);
* También puedo manejar este catchError en el Observer de la Subscription:

			MÉTODOS POST PUT Y DELETE USANDO OBSERVABLE AJAX

Estas otras formas de realizar peticiones son indispensables conocerlas.Son realmente sencillas:

const url = 'https://httpbin.org/delay/1';

/* GET: es muy sencillo,además de ser el por defecto */
const obsGET$ = ajax.get(url,{"my-header":"custom header"});
obsGET$.subscribe(console.log);

/* POST:  por post el segundo arg es el body,el tercero los headers*/
const obsPOST$ = ajax.post(url,{id:1,nombre:"Fernando"},{"my-token":"abc123"})
obsPOST$.subscribe(post => console.log('post',post))

/* PUT: exactamente igual que el POST,3 args*/
const obsPUT$ = ajax.put(url,{id:1,nombre:"Fernando"},{"my-token":"abc123"})
obsPUT$.subscribe(put => console.log('put',put))

TIP: fijate que los headers se traducen a My-Token,aunque escriba my-token se capitalizan por el camino.Fijate también que mi-token Javascript trataría de restar las variables mi y  token

IMPORTANTE: también se puede usar una opción más dinámica,igual que con fetch.Fijate que es la misma sintaxis y en su utilidad.
/* TIP:puedo realizar una petición con más dinamismo en las opciones,como el modo, usando ajax({options}) en vez de ajax.method */
ajax({
  url:url,//redundante desde ECMA6
  method:'POST',
  headers:{"header-programatico":"barsa apesta"},
  body:{
    id:2,
    nombre:'Spiderman'
  }
}).subscribe(prog => console.log('prog',prog))

			SECCION 09 OPERADORES DE TRANSFORMACIÓN

Esta sección es fundamental.Veré como combinar streams de datos(Observables) mediante operadores de aplanamiento switchMap,mergeMap,mergeAll,concatMap,...

			INTRODUCCION AL PROBLEMA Y NECESIDAD DE COMBINAR OBSERVABLES

Bien,imaginemos un input de texto y que quiero hacer una petición con la entrada de ese <input>:
TIP^: Typescript no es capaz de saber que elemento HTML dispara el Evento,y las propiedades de event.target cambian segun se disparen en un Input o un Textarea,etc,por eso el problema:

input$.pipe(
  debounceTime(500),
  map( (event:KeyboardEvent) => {
    const texto = event.target['value']; //solución mala,pero válida
    const texto = (event.target as HTMLInputElement).value ó
    const texto = (<HTMLInputElement>event.target).value
    return ajax.getJSON(`https://api.github.com/users/${texto}`)
  })
).subscribe(resp => {
  resp.pipe(
    pluck('url')
  )
  .subscribe(data => console.log(data))
})

			OPERADOR COMBINACIÓN STREAMS MERGE ALL

El mergeAll es el primer operador que va a trabajar con varios streams.Colecciona todas las emisiones provenientes de los inner Observables del Observable fuente y lo devuelve como otro Observable.Puede especificarse el nivel de anidación de Observables internos(por defecto infinitos??)

La firma es mergeAll(concurrent:number):Observable
Imaginando que un stream interno emite a b c y otro emite e y despues f y un tercer inner flujo/Observable emite g y h la salida sería simplemente la emisión secuencial de cada uno de los hijos:
a b c e f g h <- es decir,simplemente fusiona los streams internos en uno.
El Observable se completará cuando la última de las emisiones haya sido emitida.

TIP:estos operadores que combinan streams se conocen como operadores de combinación.Veamos pues como mejorar el código anterior usandolos:

const input$ = fromEvent<KeyboardEvent>(textInput,'keyup');
 
input$.pipe(
  debounceTime(500),
  pluck('target','value'),
  map(texto => ajax.getJSON(`https://api.github.com/search/users?q=${texto}`)),
  mergeAll(), //el inner Stream es el ajax.getJSON,fijate que mergeAll va despues 
  pluck('items') <- aqui ya estoy operando sobre la salida del mergeAll(que recibe las responses) 
).subscribe(console.log)
Diria que puedo ver al mergeAll como que concatena las emisiones del source Observable con las subsiguientes emisiones de sus inner Observables,ya que se suscribe a ellos y los dispara.

			VIDEO 77 TIPANDO LOS OPERADORES

Es importante tipar la entrada y salida en los operadores de streams,para mantener el tipado entre emisiones/streams.
TIP: no es necesario tipar todo,sólo cuando se pierda el tipado.Por ejemplo,en el ejemplo el debounceTime sabe perfectamente que recibe un KeyboardEvent,pero el pluck se pierde.

Fijate que a la hora de tipar pluck debe cambiarse por un map:
input$.pipe(
  debounceTime(500),
  map<KeyboardEvent, string>(event => (<HTMLInputElement>event.target).value),
  map<string, Observable<GithubUsers>>(texto => ajax.getJSON(`https://api.github.com/search/users?q=${texto}`)),
  mergeAll(),
  map<GithubUsers, GithubUser[]>(item => item.items)
).subscribe(resp => console.log(resp[0].avatar_url))

			VIDEO 78 OPERADOR COMBINACIÓN MERGE MAP

De nuevo fijate que al llamar a este tipo de operadores con un inner Observable lo que recibo es el resultado de suscribirse a ese Observable.Esto es muy importante,pues se dispara la Subscription sólo con usar mergeMap,switchMap,etc...

MergeMap permite que múltiples inner Subscriptions esten activas al mismo tiempo(si necesito que sólo sea una debo usar switchMap).Y si necesito que el orden de las susbscripciones internas sea secuencial,debo usar concatMap
TIP: switchMap completa cada innerSubscription cuando el Observable interno emita,lo cual lleva a que sólo pueda haber uno activo.(supongo que se autosuscribe en la siguiente emision de ese Observable,pero siempre la cancela,lo cual es importante).

const myPromise = (val: string | number) => new Promise((resolve) => setTimeout(() => resolve("In the resolve: " + val), 4000))

const source$ = of('Hello');

source$.pipe(
  mergeMap(myPromise) //va a recibir 'Hello',
).subscribe(console.log)

const numbers$ = of(...[1, 2, 7, 5])
numbers$.
  pipe(mergeMap(myPromise)).subscribe(console.log)

const mouseDown$ = fromEvent(document, 'mousedown')
const mouseUp$ = fromEvent(document, 'mouseup')
const interval$ = interval();

mouseDown$.pipe(
  mergeMap(() => interval$
    .pipe(
      debounceTime(500),
      takeUntil(mouseUp$))),
).subscribe(console.log) <- aqui veré la emisión del mergeMap de forma automática,ojo!

Fijate que el echo de que reciban como argumento las emisiones del padre abre un abanico de posibilidades.En cuanto a las diferencias con mergeAll.
mergeAll: fusionará todos los observables sin recibir parámetros y manda las emisiones de cada uno(propagadas).OJO,DE NUEVO,ME AUTOSUSCRIBO AL OBSERVABLE QUE RETORNA DE UNIR TODO
mergeMap: recibe como parámetro cada emisión del padre y crea un nuevo Observable,recuerda que mergeMap o switchMap no retorna ese Observable,sino que automaticamente pasará su emisión al subscribe del padre(esto es importantísimo).

Veamos ahora un pequeño problema que tiene el mergeMap por dejar todas las Subscriptions abiertas:

const url = 'https://httpbin.org/delay/1?arg=';
input$.pipe(
  map<KeyboardEvent, string>(event => (<HTMLInputElement>event.target).value),
  mergeMap( texto => ajax.getJSON(url+texto)) 
).subscribe(console.log)

* Fijate que por cada input me va a realizar una petición,¿realmente quiero esto?.Veamos que pasa si tecleo 'abc'.
{args: {…}, data: '', files: {…}, form: {…}, headers: {…}, …}
{args: {…}, data: '', files: {…}, form: {…}, headers: {…}, …}
{args: {…}, data: '', files: {…}, form: {…}, headers: {…}, …}
Me hace la petición tres veces.La solución es usar un switchMap o un debounceTime.

Un simple debounceTime cambiará esto,pues solo soltará una emisión por cada X mls:
const url = 'https://httpbin.org/delay/1?arg=';
input$.pipe(
  debounceTime(500), <- input$ ya sólo emitirá cada 500ms,perfecto
  map<KeyboardEvent, string>(event => (<HTMLInputElement>event.target).value),
  mergeMap( texto => ajax.getJSON(url+texto)) 
).subscribe(console.log)

				VIDEO 80 SWITCH MAP

El switchMap,al igual que el mergeMap recibe una callback con la emisión del Observable source como argumento y retorna un Observable,al que automáticamente me suscribiré y tendré la emisión en la Subscription padre.
A diferencia del mergeMap,el switchMap sólo va a mantener un Observable interno activo a la vez.

Fijate que interesante si cambiamos el ejemplo anterior a un switchMap:

1?arg=a	 (canceled)	xhr	VM388:1	0 B	421 ms	XHR
1?arg=asi (canceled)	xhr	VM388:1	0 B	302 ms	XHR
1?arg=asa (canceled)	xhr	VM388:1	0 B	104 ms	XHR
1?arg=asas (canceled)	200	xhr	VM388:1	1.1 kB	1.11 s	

				DIFERENCIAS ENTRE MERGEMAP Y SWITCHMAP

Fijate que sucede si uso mergeMap de esta forma:

const click$ = fromEvent(document,'click');
const interval$ = interval(1000);

click$.pipe(
  mergeMap( () => interval$)
).subscribe(console.log)

Por cada click voy a crear un nuevo interval,pero sin desuscribirme al anterior.En pocos clicks tendré demasiados.¿Realmente alguién puede querer esto?
Pero que sucede si lo cambio por un switchMap?:

click$.pipe(
  switchMap( () => interval$),
).subscribe(console.log)

Puedo ver que en cada click se cancela el interval anterior,y lógicamente,empieza uno nuevo desde 0(es por esto que se cancelaban las peticiones,porque al emitir de nuevo el Observable source cancela la Subscripcion interna)
Resumen: el switchMap sólo es capaz de mantener una Subscription interna activa,mientras que el mergeMap es capaz de mantener todas activas

				VIDEO 82 CONCAT MAP

Este operador de aplanamiento "concatena" los inner Observables.Es importante entender que debe terminar el Observable interno A para que empiece el B.Si por ejemplo tuviera esto:

click$.pipe(
  concatMap( () => interval$.pipe(take(5)).
en el primer click empezará el interval 1 a emitir 4 valores.Si hiciera dos clicks más se concatenarían dos intervalos más,pero no van a emitirse en paralelo como fuera con un mergeMap.

Puedo observar que con concatMap me aseguro que el Observable interno emita sus valores,a diferencia también de con un switchMap,que una nueva emisión del padre implica cancelar el hijo.

				VIDEO  83 EXHAUST MAP

El exhaustMap es un tanto peculiar,ya que sólo va a tener una única subscription interna como máximo.A diferencia del switchMap que una nueva emision del padre la cancela o del concatMap que las pone en cola el exhaustMap ignorará cualquier emisión del padre que pase al hijo mientras éste está emitiendo.
En el momento que el inner Stream este vacío,si el padre emite algo de nuevo pasará al hijo el valor de la emisión y arrancará ese nuevo Observable.
En pocas palabras,solamente mantiene una Suscription activa interna a la vez:

const interval$ = interval(500).pipe(take(3));
const click$ = fromEvent(document,'click');

click$.pipe(
  exhaustMap( () => interval$)
).subscribe(console.log)
* Mientras esté emitiendo el interval ya puedo hacer más clicks que los va a ignorar.Este operador es muy útil cuando el Observable padre emite muchos valores(spameo de emisiones).

			EJERCICIO COMPARACIÓN MERGE-MAP SWITCH-MAP Y EXHAUST-MAP

Vamos a hacer un pequeño form que haga un login a https://reqres.in/api/login:			

const peticionHttpLogin = (userCredentials) => ajax.post('https://reqres.in/api/login?delay=1',userCredentials).pipe(pluck('response','token'))

const form = document.createElement('form');
const inputEmail = document.createElement('input');
const inputPass = document.createElement('input');
const submitBtn = document.createElement('button');

inputEmail.type = 'email';
inputEmail.placeholder = 'Enter email...';
inputEmail.value = 'eve.holt@reqres.in';

inputPass.type = 'password';
inputPass.placeholder = 'Enter placeholder...';
inputPass.value = 'cityslicka';

submitBtn.innerHTML = 'Ingresar'
submitBtn.style.cursor = 'pointer'

form.append(inputEmail, inputPass, submitBtn);
document.querySelector('body').append(form)

// streams
const submitForm$ = fromEvent<SubmitEvent>(form, 'submit')
    .pipe(
      tap((event) => event.preventDefault()),
      map( ev => ({
        email: ev.target[0].value,
        password: ev.target[1].value,
      })),
      // mergeMap(peticionHttpLogin) //no es una buena idea usar el mergeMap
      // switchMap(peticionHttpLogin) // el switch cancelará todas.Bien
      exhaustMap(peticionHttpLogin)//pero el exhaust ni siquiera las manda.
      );

submitForm$.pipe(
).subscribe( token => console.log(token))  

Bien,pero que va a pasar con el mergeMap si doy al submit 5 veces?.Que hará 5 peticiones.
Con un switchMap las cancelará.Bien.
Pero el exhaustMap es incluso mejor,ya que ni siquiera las tiene que cancelar.

			SECCION 10 OPERADORES COMBINACIÓN OBSERVABLES

En esta sección veré operadores y métodos para combinar las emisiones de los observables o bien varios observables entre sí.
Veré los operadores siguientes: startWith,endWith,concat,merge,combineLatest,forkJoin.


				OPERADOR START WITH

Como el nombre indica,este operador me permite "incrustar" una primera emisión antes de la primera emisión del Observable.
El valor a mandar puede ser un string,un object,un number,inclusive otro Observable...

const numbers$ = of(1,2,3)

numbers$.pipe(
  startWith('Starting the of Observable...')
).subscribe(console.log)

				OPERADOR END WITH

De forma similar al startWith,el operador endWith emitirá un último valor antes de que se complete el Observable con lo que quiera como valor:

numbers$.pipe(
  startWith('Starting the of Observable...'),
  endWith('Finished the of Observable...')
).subscribe(console.log)

			LABORATORIO LOADING CON START WITH

Fijate la práctica tan interesante y lo fácil que es añadir un Loading condicionalmente con este operador:

const loadingDiv = document.createElement('div')
loadingDiv.classList.add('loading');
loadingDiv.innerText = 'Cargando...'

const body = document.querySelector('body')

ajax.getJSON('https://reqres.in/api/users/2?delay=3')
  .pipe(
    startWith(true),
  )
  .subscribe(resp => {
    if (resp===true) {
      body.append(loadingDiv);
    } else {
      document.querySelector('.loading').remove()
    }
    console.log(resp);
  })
En un ejercicio real no lo añadiría al body,pero es super-sencillo.Podría preguntar a Unai como hizo los loadings.Aunque se consigue con un simple condicional.

				FUNCION CONCAT

La función concat(obs1$,obs2$,obs3$) es una función que recibe Observables por argumento.NO confundir con el operador concatMap.
También puede recibir Iterables por argumento.
Esta función es muy parecida a lo que hace concatMap,primero emitirá todos los valores que emita el Observable 1,despues los que emita el 2 y asi sucesivamente.
Si el Observable 1 no fuera finito el 2 y el 3 se quedarían esperando indefinidamente,luego hay que tener cuidado con lo que se concatena. 

const interval$ = timer(500, 1000);

concat(
  interval$.pipe(take(5)),
  interval$.pipe(take(3)),
  [1,2,3,4], <- recuerda que puede recibir un iterable cualquiera también
  of('finished'))
.subscribe(console.log)

				FUNCION MERGE 

Esta funcion merge(obs$1,obs$2,obs3$) es la contrapartida al mergeMap pero en función.El resultado será la combinación de las emisiones de los observables,a diferencia de concat que las concatena o emite en secuencia,merge emitirá cada valor en paralelo				

const keyup$ = fromEvent(document,'keyup');
const click$ = fromEvent(document,'click');

merge(
  keyup$.pipe(pluck('type')),
  click$.pipe(pluck('type')),
  ).subscribe(console.log)
  
Si bien este ejemplo no tiene mucho sentido puedo ver que mergea las emisiones indefinidamente.

NOTA: estas funciones que ahora vienen de rxjs antes estaban como operadores que venian de rxjs/operators

				FUNCION COMBINE LATEST

La funcion combineLatest(obs1,obs2) permite mandar Observables como argumento,combinarlos y emitir los valores de todos los observables internos simultáneamente.Esto por cada emisión de cada uno.
Es decir,imaginando que tengo dos Observables y uno emite 'a'.CombineLatest esperará que emita el otro,que por ejemplo emite 1.LA salida que emitirá combineLatest será 'a1',despues 'b2'(imaginando que emiten b y 2).
NOTA:la salida es un arreglo realmente,manteniendo el orden de emisión(por ejemplo [a,1] ó [1,a])

Fijate que cada Observable debe emitir al menos un valor(y obviamente si uno emitierá varios se cogerá el último valor(mirar si hay combineFirst,etc...).

const input1 = document.createElement('input');
const input2 = document.createElement('input');

input1.placeholder = "Enter email..."
input1.type = "email"
input2.placeholder = "Enter password..."
input2.type = "password"

document.querySelector('body').append(input1,input2);

const getInputStream = (elem:HTMLElement) => {
  return fromEvent<KeyboardEvent>(elem,'keyup')
    .pipe(
      map<KeyboardEvent,string>(event => (event.target as HTMLInputElement).value))
}

combineLatest(
  getInputStream(input1),
  getInputStream(input2),
).subscribe(console.log)

				FUNCION FORKJOIN

Asi como el merge,concat o el combineLatest la funcion forkJoin(obs1,obs2,obs3) también puede recibir varios Observables o iterables para trabajar como argumento.
Igual que con el concat,los observable tienen que ser finitos
Justo en el momento en que los tres Observables se completen dejando de emitir valores,el forkJoin va a emitir el valor de las tres últimas emisiones como un arreglo.
TIP:con una pequeña configuración se puede pasar ese arreglo a un objeto

const numbers$ = of(1, 2, 3, 4);
const interval$ = interval(1000).pipe(take(3), map(x => x += 1))
const letras$ = of('a', 'b', 'c').pipe(delay(3500))

/* por defecto va a ser un Array */
forkJoin(numbers$, interval$, letras$).subscribe(console.log)
/* puedo usar forkJoin({}) para que arroje un object.Las propiedades serán el nombre del los observables por defecto */
forkJoin({
  num: numbers$,
  interval: interval$,
  letra: letras$
})
  .subscribe(resp => {
    console.log(resp)
  })

Fijate que un objeto suele ser algo más manejable que un arreglo,y que puedo renombrar la entrada de los argumentos a lo que quiera

				CASO DE USO MÁS COMÚN 

El caso de uso más común es realizar peticiones AJAX de manera simultánea/paralela. 				
const GITHUB_API_URL = 'https://api.github.com/users';
const GITHUB_USER = 'klerith';

forkJoin({
  usuario: ajax.getJSON(`${GITHUB_API_URL}/${GITHUB_USER}`,{"header-custom":"custom 01"}),
  repos: ajax.getJSON(`${GITHUB_API_URL}/${GITHUB_USER}/repos`,{"header-custom":"custom 01"}),
  gists: ajax.getJSON(`${GITHUB_API_URL}/${GITHUB_USER}/gists`,{"header-custom":"custom 01"}),
}).subscribe(console.log)
Desde luego,esto es algo que necesito memorizar.
TIP:normalmente querré manejar los errores.Podría hacerlo en cada ajax.getJSON o al forkJoin,es decir al grupo de Observables o a cada uno:

forkJoin({
  usuario: ajax.getJSON(`${GITHUB_API_URL}/${GITHUB_USER}`,{"header-custom":"custom 01"}),
  repos: ajax.getJSON(`${GITHUB_API_URL}/${GITHUB_USER}/repos`,{"header-custom":"custom 01"}),
  gists: ajax.getJSON(`${GITHUB_API_URL}/${GITHUB_USER}/gists`,{"header-custom":"custom 01"}),
}).pipe(
  catchError(err => of(err)),
).subscribe(console.log)

Obviamente,son cosas diferentes,realizarlo asi no impedirá que se realizen la peticiones pero al saltar el catchError general no veré su resultado(fijate que esto es o viene todo o da error).

IMPORTANTE: puedo manejar el error individualmente y de esa forma cada Observable interno que se resuelva si enviará su response.Asi que realmente puedo actuar como quiera(o vienen todas o ninguna,o bien puede venir la que se resuelva).

forkJoin({
  usuario: ajax.getJSON(`${GITHUB_API_URL}/${GITHUB_USER}`,{"header-custom":"custom 01"}),
  repos: ajax.getJSON(`${GITHUB_API_URL}/${GITHUB_USER}/repos`,{"header-custom":"custom 01"}).pipe(catchError(err => of(err,'fallo en getUsers'))),
  gists: ajax.getJSON(`${GITHUB_API_URL}/${GITHUB_USER}/gists`,{"header-custom":"custom 01"}),
}).pipe(
  // catchError(err => of(err)),
).subscribe(console.log)

Fijate que combina todo lo bueno,permite ejecutar consultas en paralelo y gestionar el error como yo quiera.Memorizarlo.

			SECCION 11 EJERCICIOS DE REFORZAMIENTO

TIP: Fernando optó por usar funciones autoinvocadas para evitar conflictos entre archivos al mismo nivel,ya que crean un contexto o módulo diferente cada una por ser funciones autoejecutables:
( () => {
   <- contexto diferente por cada una de ellas.
})();

IMPORTANTE: fijate que en el último ejercicio el retorno de zip va a ser resuelto por estar en un switchMap.Viene perfecto para agrupar peticiones encadenadas(fijate que necesitaré switchMap,etc, para que lo resuelva).Increible:

getRequest(url).pipe(
  switchMap( resp => zip(of(resp),resp.species[0]))
  map( ([personaje,nave]) => ({personaje,nave})) <- fijate que fácil de array a objeto
  ).subscribe(console.log) <- no puede ser más sencillo.Memoriza zip 
